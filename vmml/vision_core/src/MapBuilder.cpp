/*
 * MapBuilder.cpp
 *
 *  Created on: Oct 8, 2019
 *      Author: sujiwo
 */

#include "MapBuilder.h"
#include "BaseFrame.h"
#include "Matcher.h"
#include "Triangulation.h"


using namespace std;
using namespace Eigen;


namespace Vmml {


MapBuilder::MapBuilder(const CameraPinholeParams &mycam) :
	camera0(mycam)
{
	vMap.reset(new VisionMap);
	vMap->addCameraParameter(camera0);
}


bool
MapBuilder::feed(cv::Mat inputImage)
{
	auto currentFrame = BaseFrame::create(inputImage, camera0);
	currentFrame->computeFeatures(vMap->getFeatureDetector());

	// No frame yet
	if (lastAnchor==0) {
		auto K1 = KeyFrame::fromBaseFrame(*currentFrame, vMap);
		lastAnchor = K1->getId();
		return vMap->addKeyFrame(K1);
	}
	else {

		if (hasInitialized==false) {
			// Try initialization
			if (initialize(currentFrame)==true) {
				hasInitialized = true;
				return true;
			}

			else {
				// skip to next frame, maybe better
				return false;
			}
		}

		// Tracking mode
		else {
			track(currentFrame);
		}
	}

	return true;
}


MapBuilder::~MapBuilder() {
	// TODO Auto-generated destructor stub
}


bool
MapBuilder::initialize(BaseFrame::Ptr &f2)
{
	auto K1 = vMap->keyframe(lastAnchor);
	Matcher::PairList f12matches, f12matchesInliers;

	int Ns1 = Matcher::matchBruteForce(*K1, *f2, f12matches);
	if (Ns1<10)
		return false;
	TTransform motion = Matcher::calculateMovement(*K1, *f2, f12matches, f12matchesInliers);
	if (f12matchesInliers.size()<10)
		return false;
	f2->setPose(motion);

	map<uint, Vector3d> mapPoints;
	float parallax;
	TriangulateCV(*K1, *f2, f12matchesInliers, mapPoints, &parallax);
	if (mapPoints.size() < 10)
		return false;

	auto K2 = KeyFrame::fromBaseFrame(*f2, vMap);
	vMap->addKeyFrame(K2);

	// Add points to Map
	for (auto &ptPair: mapPoints) {
		auto inlierKeyPointPair = f12matchesInliers[ptPair.first];
		auto pt3d = MapPoint::create(ptPair.second);
		vMap->addMapPoint(pt3d);
		vMap->addMapPointVisibility(pt3d->getId(), K1->getId(), inlierKeyPointPair.first);
		vMap->addMapPointVisibility(pt3d->getId(), K2->getId(), inlierKeyPointPair.second);
		vMap->updateMapPointDescriptor(pt3d->getId());
	}
	K1->computeBoW();
	K2->computeBoW();

	vMap->updateCovisibilityGraph(K1->getId());
	lastAnchor = K2->getId();
	return true;
}


bool
MapBuilder::track(BaseFrame::Ptr &frame)
{
	auto kAnchor = vMap->keyframe(lastAnchor);

	vector<Matcher::KpPair> featurePairs_1_2;

	int Ns1 = Matcher::matchBruteForce(*kAnchor, *frame, featurePairs_1_2);
	if (Ns1<10)
		return false;

	// Separate old map points (which visible in KF1) from potential new ones (which will be generated by triangulation)
	set<kpid> kp1InMap;
	for (auto &p: vMap->allMapPointsAtKeyFrame(lastAnchor))
		kp1InMap.insert(p.second);
	vector<Matcher::KpPair> newMapPointPairs, oldMapPointPairs;

	for (auto &kpPair: featurePairs_1_2) {
		if (kp1InMap.find(kpPair.first) != kp1InMap.end()) {
			oldMapPointPairs.push_back(kpPair);
		}
		else {
			newMapPointPairs.push_back(kpPair);
		}
	}

	// XXX: Find solution for insufficient pairs !
	if (oldMapPointPairs.size() < 4) {
		cerr << "Insufficient points!\n";
		return false;
	}

	// Estimate pose for KF2
	Pose PF2;
	Matcher::solvePose(*kAnchor, *frame, oldMapPointPairs, PF2);
	frame->setPose(PF2);
	auto Knew = KeyFrame::fromBaseFrame(*frame, vMap);
	vMap->addKeyFrame(Knew);

	// Put point appearances
	for (int i=0; i<oldMapPointPairs.size(); i++) {
		mpid ptId = vMap->getMapPointByKeypoint(lastAnchor, oldMapPointPairs[i].first);
		vMap->addMapPointVisibility(ptId, Knew->getId(), oldMapPointPairs[i].second);
	}

	// Triangulation for new map points
	map<uint, Vector3d> mapPoints;
	float parallax;
	TriangulateCV(*kAnchor, *Knew, newMapPointPairs, mapPoints, &parallax);
	for (auto &p: mapPoints) {
		auto ptn = MapPoint::create(p.second);
		vMap->addMapPoint(ptn);
		vMap->addMapPointVisibility(ptn->getId(), lastAnchor, newMapPointPairs[p.first].first);
		vMap->addMapPointVisibility(ptn->getId(), Knew->getId(), newMapPointPairs[p.first].second);
		vMap->updateMapPointDescriptor(ptn->getId());
	}

	// XXX: Update descriptors of all related map points before exiting this function

	return true;
}


} /* namespace Vmml */


