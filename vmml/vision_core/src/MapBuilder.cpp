/*
 * MapBuilder.cpp
 *
 *  Created on: Oct 8, 2019
 *      Author: sujiwo
 */

#include "MapBuilder.h"
#include "BaseFrame.h"
#include "Matcher.h"
#include "Triangulation.h"
#include "Optimizer.h"


using namespace std;
using namespace Eigen;


namespace Vmml {


MapBuilder::TmpFrame::
	TmpFrame(cv::Mat img, std::shared_ptr<VisionMap> &_parent) :
		BaseFrame(img, _parent->getCameraParameter(0), Pose::Identity()),
		parent(_parent)
{
	computeFeatures(parent->getFeatureDetector());
}


MapBuilder::TmpFrame::Ptr
MapBuilder::TmpFrame::create(cv::Mat img, shared_ptr<VisionMap> &_parent)
{ return Ptr(new TmpFrame(img, _parent)); }


bool
MapBuilder::TmpFrame::initializeMatch(const KeyFrame::Ptr &kf)
{
	parentKeyFrame = kf;

	int Ns1 = Matcher::matchBruteForce(*parentKeyFrame, *this, matchesToKeyFrame);
	if (Ns1<10)
		return false;

	Matcher::PairList f12matchesInliers;
	TTransform motion = Matcher::calculateMovement(*parentKeyFrame, *this, matchesToKeyFrame, f12matchesInliers);
	if (f12matchesInliers.size()<10)
		return false;
	this->setPose(motion);

	matchesToKeyFrame = f12matchesInliers;
	return true;
}


bool
MapBuilder::TmpFrame::track(const kfid &kf)
{
	parentKeyFrame = parent->keyframe(kf);

	int Ns1 = Matcher::matchBruteForce(*parentKeyFrame, *this, matchesToKeyFrame);
	if (Ns1<10)
		return false;

	// Separate old map points (which visible in KF1) from potential new ones (which will be generated by triangulation)
	set<kpid> kp1InMap;
	for (auto &p: parent->allMapPointsAtKeyFrame(kf))
		kp1InMap.insert(p.second);

	for (auto &kpPair: matchesToKeyFrame) {
		if (kp1InMap.find(kpPair.first) != kp1InMap.end()) {
			prevMapPointPairs.push_back(kpPair);
		}
		else {
			candidatesMapPointPairs.push_back(kpPair);
		}
	}

	cout << "Tracking; total: " << matchesToKeyFrame.size() << "; map: " << prevMapPointPairs.size() << "; cand: " << candidatesMapPointPairs.size() << endl;

	// XXX: Find solution for insufficient pairs !
	if (prevMapPointPairs.size() < 4) {
		cerr << "Insufficient points!\n";
		return false;
	}

	// Estimate pose for KF2
	Pose PF2;
	Matcher::solvePose(*parentKeyFrame, *this, prevMapPointPairs, PF2);
	this->setPose(PF2);

	// Debugging
	TTransform movement = parentKeyFrame->pose().inverse() * PF2;
	double dx = movement.translation().norm();

	return true;
}


/*
 * XXX: Check this function
 */
bool
MapBuilder::TmpFrame::isOkForKeyFrame() const
{
	const float mapPointThresholdRatio = 0.3;

	if (float(candidatesMapPointPairs.size()) / float(matchesToKeyFrame.size()) >= mapPointThresholdRatio) {
		return true;
	}

	else return false;
}


KeyFrame::Ptr
MapBuilder::TmpFrame::toKeyFrame() const
{
	auto KF = KeyFrame::fromBaseFrame(*this, parent, 0, this->timestamp);
	KF->setPose(this->pose());
	return KF;
}


MapBuilder::MapBuilder(const CameraPinholeParams &mycam, const std::string &mapVocabularyPath) :
	camera0(mycam)
{
	vMap = std::make_shared<VisionMap>();
	vMap->addCameraParameter(camera0);
	if (mapVocabularyPath.size()!=0)
		vMap->loadVocabulary(mapVocabularyPath);
}


bool
MapBuilder::feed(cv::Mat inputImage, const ptime &timestamp)
{
	currentWorkframe = TmpFrame::create(inputImage, vMap);
	currentWorkframe->timestamp = timestamp;
	frameCounter += 1;

	// No frame yet
	if (lastAnchor==0) {
		auto K1 = KeyFrame::fromBaseFrame(*currentWorkframe, vMap);
		lastAnchor = K1->getId();
		vMap->addKeyFrame(K1);
		callFrameFunction();
		return true;
	}
	else {

		if (hasInitialized==false) {
			// Try initialization
			if (initialize()==true) {
				hasInitialized = true;
				return true;
			}

			else {
				// skip to next frame, maybe better
				return false;
			}
		}

		// Tracking mode
		else {
			track();
		}
	}

	return true;
}


MapBuilder::~MapBuilder() {
	// TODO Auto-generated destructor stub
}


bool
MapBuilder::initialize()
{
	auto anchorKeyframe = vMap->keyframe(lastAnchor);
	if (currentWorkframe->initializeMatch(anchorKeyframe)==false)
		return false;

	return createInitialMap();
}


bool
MapBuilder::track()
{
	if (currentWorkframe->track(lastAnchor)==false)
		return false;

	/*
	 * It's OK, we only continue when there has been enough 'innovation'
	 */
	if (currentWorkframe->isOkForKeyFrame()==false) {
		callFrameFunction();
		return true;
	}

	auto Knew = KeyFrame::fromBaseFrame(*currentWorkframe, vMap);
	vMap->addKeyFrame(Knew);

	// Put point appearances
	for (int i=0; i<currentWorkframe->prevMapPointPairs.size(); i++) {
		mpid ptId = vMap->getMapPointByKeypoint(lastAnchor, currentWorkframe->prevMapPointPairs[i].first);
		vMap->addMapPointVisibility(ptId, Knew->getId(), currentWorkframe->prevMapPointPairs[i].second);
		vMap->updateMapPointDescriptor(ptId);
	}

	// Triangulation for new map points
	map<uint, Vector3d> mapPoints;
	float parallax;
	TriangulateCV(*currentWorkframe->parentKeyFrame, *Knew, currentWorkframe->candidatesMapPointPairs, mapPoints, &parallax);
	cout << "Creating map points: " << currentWorkframe->candidatesMapPointPairs.size() << ", got " << mapPoints.size() << endl;
	for (auto &p: mapPoints) {
		auto ptn = MapPoint::create(p.second);
		vMap->addMapPoint(ptn);
		vMap->addMapPointVisibility(ptn->getId(), lastAnchor, currentWorkframe->candidatesMapPointPairs[p.first].first);
		vMap->addMapPointVisibility(ptn->getId(), Knew->getId(), currentWorkframe->candidatesMapPointPairs[p.first].second);
//		vMap->updateMapPointDescriptor(ptn->getId());
	}

	// Build connections to previous keyframes
	vector<kfid> kfInsToAnchor = vMap->getKeyFramesComeInto(lastAnchor);
	const kfid targetKfId = lastAnchor;
/*
	for (auto &kfx: kfInsToAnchor) {
		trackMapPoints(kfx, lastAnchor);
	}
*/

	// Check whether we need local BA
	kfInsToAnchor = vMap->getKeyFramesComeInto(lastAnchor);
/*
	if (std::find(kfInsToAnchor.begin(), kfInsToAnchor.end(), localBAAnchor)==kfInsToAnchor.end()) {
		cout << "Local BA running\n";
		auto vAnchors = cMap->getKeyFramesComeInto(lastAnchor);
		local_bundle_adjustment(cMap, lastAnchor);
		localBAAnchor = lastAnchor;
	}
*/

	vMap->updateCovisibilityGraph(lastAnchor);
	lastAnchor = Knew->getId();
	callFrameFunction();

	return true;
}


bool
MapBuilder::createInitialMap()
{
	auto anchorKeyframe = vMap->keyframe(lastAnchor);

	// Create map points
	map<uint, Vector3d> mapPoints;
	float parallax;
	TriangulateCV(*anchorKeyframe, *currentWorkframe, currentWorkframe->matchesToKeyFrame, mapPoints, &parallax);
	if (mapPoints.size() < 10)
		return false;

	auto K2 = KeyFrame::fromBaseFrame(*currentWorkframe, vMap);
	vMap->addKeyFrame(K2);

	// Add points to Map
	for (auto &ptPair: mapPoints) {
		auto inlierKeyPointPair = currentWorkframe->matchesToKeyFrame[ptPair.first];
		auto pt3d = MapPoint::create(ptPair.second);
		vMap->addMapPoint(pt3d);
		vMap->addMapPointVisibility(pt3d->getId(), anchorKeyframe->getId(), inlierKeyPointPair.first);
		vMap->addMapPointVisibility(pt3d->getId(), K2->getId(), inlierKeyPointPair.second);
	}
	cout << "New map initialized: " << mapPoints.size() << " pts\n";
	anchorKeyframe->computeBoW();
	K2->computeBoW();

	vMap->updateCovisibilityGraph(anchorKeyframe->getId());


	// Call bundle adjustment
	Optimizer::BundleAdjustment(*vMap, 50);

	// calculate median of point depths
	double depthMedian = anchorKeyframe->computeSceneMedianDepth();
	double invDepthMedian = 1.0f / depthMedian;
	if (depthMedian < 0 or vMap->getTrackedMapPointsAt(K2->getId(), 1)<100) {
		cout << "Wrong initialization" << endl;
		this->reset();
		return false;
	}

	// Scale initial baseline
	Pose p2=currentWorkframe->pose();
	Vector3d tr = p2.translation();
	tr *= invDepthMedian;
	K2->setPose(Pose::from_Pos_Quat(tr, p2.orientation()));

	// scale points
	for (auto &mpIdx: vMap->allMapPointsAtKeyFrame(lastAnchor)) {
		auto Pt = vMap->mappoint(mpIdx.first);
		Pt->setPosition(Pt->getPosition() * invDepthMedian);
	}

	lastAnchor = K2->getId();
	currentWorkframe->setPose(K2->pose());
	callFrameFunction();
	return true;
}


const int matchCountThreshold = 15;

void
MapBuilder::trackMapPoints(const kfid ki1, const kfid ki2)
{
	auto KF1 = vMap->keyframe(ki1),
		KF2 = vMap->keyframe(ki2);

	// Track Map Points from KF1 that are visible in KF2
	vector<Matcher::KpPair> pairList12;
	TTransform T12;
	Matcher::matchMapPoints(*KF1, *KF2, pairList12);
	if (pairList12.size()==0)
		return;

	map<kpid, mpid> kf1kp2mp = vMap->getAllMapPointProjectionsAt(ki1);
	// Check the matching with projection
	int pointMatchCounter = 0;
	for (int i=0; i<pairList12.size(); i++) {
		auto &p = pairList12[i];
		const mpid ptId = kf1kp2mp[p.first];

		// Try projection
		Vector3d pt3 = vMap->mappoint(ptId)->getPosition();
		Vector2d kpx1 = KF1->project(pt3);
		Vector2d kpf = KF2->project(pt3);
		double d = ( kpf-KF2->keypointv(p.second) ).norm();
		if (d >= 4.0)
			continue;

		// This particular mappoint is visible in KF2
		pointMatchCounter += 1;
		vMap->addMapPointVisibility(ptId, ki2, p.second);
	}

	if (pointMatchCounter > matchCountThreshold) {
		vMap->updateCovisibilityGraph(ki1);
		cerr << "Backtrace: Found " << pointMatchCounter << "pts\n";
	}

}


bool
MapBuilder::createNewKeyFrame()
{

}


void
MapBuilder::reset()
{
	vMap->reset();
	hasInitialized = false;
	lastAnchor = 0;
}


} /* namespace Vmml */


