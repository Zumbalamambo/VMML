/*
 * MapBuilder.cpp
 *
 *  Created on: Oct 8, 2019
 *      Author: sujiwo
 */

#include "MapBuilder.h"
#include "BaseFrame.h"
#include "Matcher.h"
#include "Triangulation.h"


using namespace std;
using namespace Eigen;


namespace Vmml {


MapBuilder::MapBuilder(const CameraPinholeParams &mycam) :
	camera0(mycam)
{
	vMap.reset(new VisionMap);
	vMap->addCameraParameter(camera0);
}


bool
MapBuilder::feed(cv::Mat inputImage)
{
	auto currentFrame = BaseFrame::create(inputImage, camera0);

	// No frame yet
	if (lastAnchor==0) {
		auto K1 = KeyFrame::fromBaseFrame(*currentFrame, vMap);
		lastAnchor = K1->getId();
		return vMap->addKeyFrame(K1);
	}
	else {

		// Try initialization
		if (initialize(currentFrame)==true) {
			auto newKf = KeyFrame::fromBaseFrame(*currentFrame, vMap);
			vMap->addKeyFrame(newKf);
			lastAnchor = newKf->getId();
			return true;
		}

		else {
			vMap->reset();
			return false;
		}

		// Tracking mode

	}

	return true;
}


MapBuilder::~MapBuilder() {
	// TODO Auto-generated destructor stub
}


bool
MapBuilder::initialize(BaseFrame::Ptr &f2)
{
	auto K1 = vMap->keyframe(lastAnchor);
	Matcher::PairList f12matches, f12matchesInliers;

	int Ns1 = Matcher::matchBruteForce(*K1, *f2, f12matches);
	if (Ns1<10)
		return false;
	TTransform motion = Matcher::calculateMovement(*K1, *f2, f12matches, f12matchesInliers);
	if (f12matchesInliers.size()<10)
		return false;
	f2->setPose(motion);

	map<uint, Vector3d> mapPoints;
	float parallax;
	TriangulateCV(*K1, *f2, f12matchesInliers, mapPoints, &parallax);
	if (mapPoints.size() < 10)
		return false;

	// Add points to Map
	for (auto &ptPair: mapPoints) {

	}

	return true;
}


bool
MapBuilder::track(BaseFrame::Ptr &frame)
{
	auto kAnchor = vMap->keyframe(lastAnchor);

	vector<Matcher::KpPair> featurePairs_1_2;

	int Ns1 = Matcher::matchBruteForce(*kAnchor, *frame, featurePairs_1_2);
	if (Ns1<10)
		return false;

	// Separate old map points (which visible in KF1) from potential new ones (which will be generated by triangulation)
	set<kpid> kp1InMap;
	for (auto &p: vMap->allMapPointsAtKeyFrame(lastAnchor))
		kp1InMap.insert(p.second);
	vector<Matcher::KpPair> newMapPointPairs, oldMapPointPairs;

	for (auto &kpPair: featurePairs_1_2) {
		if (kp1InMap.find(kpPair.first) != kp1InMap.end()) {
			oldMapPointPairs.push_back(kpPair);
		}
		else {
			newMapPointPairs.push_back(kpPair);
		}
	}

	// XXX: Find solution for insufficient pairs !
	if (oldMapPointPairs.size() < 4) {
		cerr << "Insufficient points!\n";
		return false;
	}

	// Estimate pose for KF2
	Pose PF2;
	Matcher::solvePose(*kAnchor, *frame, oldMapPointPairs, PF2);

	frame->setPose(PF2);
}


} /* namespace Vmml */


